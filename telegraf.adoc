//
// Copyright (c) 2020-2021 NVI, Inc.
//
// This file is part of the FSL10 Linux distribution.
// (see http://github.com/nvi-inc/fsl10).
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
//

:doctype: book

= DRAFT telegraf installation for FS computers
E. Himwich, C. Frock, C. Coughlin, K. Imai
Version 1.3 - August 2021

:sectnums:

:toc:
== Introduction

This document covers the steps for installing _telegraf_ (a collector
for the MAS) for Field System computers. It assumes that there are
both _operational_ and _spare_ computers in use. There are referred to
as _fs1_ and _fs2_, respectively. You should of course replace those
with the names of the computers you are using, if different. If there
is only one computer, you can omit the steps involving _fs2_ and not
install the _set_telegraf_ utility.

The archive for _gromet_ can be found at:
https://github.com/nvi-inc/telegraf

With two computers, _telegraf_ should be installed on both _fs1_ and
_fs2_. The one on _fs1_ is the nominal operational installation. The
one on _fs2_ collects computer performance information by default.
However, the _set_telegraf_ utility (see the appendix
<<set_telegraf utility>> below for the details) can be used to make it
the operational version if needed.

The installation assumes that _gromet_ is used to serve met. data. If
_metserver_ is being used instead, you should either replace it with
_gromet_ _or_ substitute _metserver_ in place of _gromet_ in the
<<fs1 installation>> step and following steps. Additional instructions
for  using _metserver_ or no met. data server are included as well.

If you are not already using _gromet_ and want to, instructions for
installing _gromet_ are in provided in _gromet_ installation document
at https://github.com/nvi-inc/gromet_install.  If you plan to use
_gromet_, installing it first or combining it with _telegraf_ is
described in <<Combining with gromet installation>> section.

The installation process uses the "`Recoverable testing`" procedure of
FSL10 with a RAID to enable easy recovery in case of a problem. This
has the advantage that if (i) steps are missing from the procedure or
(ii) errors occur, and either or both can't be recovered from
directly, it is relatively easy to return to the original state and
start over. If you are using some other FSL__x__ or don't have a RAID,
you should skip the use and restoration steps of the "`Recoverable
testing`" procedure or substitute a different one.

== Combining with gromet installation

It is possible to combine the installation of _telegraf_ with that of
_gromet_. The only downside of that is that if it is necessary to
revert the _telegraf_ installation, the installed _gromet_ will be
lost also. However, that should be fairly easy to recover on the next
attempt. The complete _gromet_ installation can be done before the
_telegraf_ installation to decouple them.


TIP: To decouple the _gromet_ and _telegraf_ installation, complete
the "`Restoring RAID`" step (at
https://nvi-inc.github.io/gromet_install/#_restoring_raids) in the
__gromet__ installation document and allow the RAIDs to fully recover
before using this document to install __telegraf__.

To combine the two installations:

. Follow the steps in the _gromet_ installation document (at
https://nvi-inc.github.io/gromet_install/) down to, but not including,
the "`Restoring RAID`" step (at
https://nvi-inc.github.io/gromet_install/#_restoring_raids).

. Then proceed to the <<fs1 installation>> section. You should skip
<<Preparing fs1>> and <<Preparing fs2>> steps that follow.

If it is necessary to revert the combined installation, follow the
steps in the <<Reverting the installation>> section below.

== Reverting the installation

If it is not possible finish the installation before the next
operational use of the system or disk rotation, the systems can be
reverted to their previous configuration.  For each system
that had the primary disk "dropped" follow the _failed_ branch of
the recoverable testing procedure at:

https://nvi-inc.github.io/fsl10/raid.html#_recoverable_testing

It will require several hours for the refresh operation
to complete. The system can be used for operations, but not a disk
rotation, while the refresh is in progress. Later, the installation
can be tried again from scratch when it is convenient.

CAUTION: If you use _metserver_, depending on where in the process the
decision to revert the installation is made, it may also be necessary
to move the MET4A and wind sensor serial connectors back to _fs1_.

When reverting the installation, you may also need to re-enable the
data logger access on MAS, as described in section
<<Disabling data logger access from the MAS>> below.

== Disabling data logger access from the MAS

The _telegraf_ installation on the FS computers will query the data
logger. If the _telegraf_ on the MAS computer is already accessing the
data logger, it will need to be disabled to avoid a conflict. To
disable accessing the data logger on the MAS computer, comment out the
data logger lines in the _telegraf_ configuration file on the MAS
computer and restart _telegraf_ there.

If the installation needs to be reverted (see more details in section
<<Reverting the installation>> above) you will need to re-enable data logger
access on the MAS computer to return to the previous configuration. To
do this, uncomment the relevant lines in the _telegraf_ configuration
file on the MAS computer and restart _telegraf_ there.

== Firewall setup

If you have an internal site firewall make sure it is set to allow
_fs1_ and _fs2_ to push data to the MAS.

== fs1 installation

All steps in this section are to be performed on the _fs1_ computer.

=== Preparing fs1

NOTE: If you are combining the _gromet_ and _telegraf_ installations
and have _not_ restored the RAIDs as part of the _gromet_
installation, you should skip this step and proceed to the next step,
<<Installing telegraf on fs1>>, below.

. Follow the directions for the recoverable test procedure at:

+

https://nvi-inc.github.io/fsl10/raid.html#_recoverable_testing

. Once the primary disk has been dropped from the RAID, move onto the
next step, <<Installing telegraf on fs1>>, below.

=== Installing telegraf on fs1

. Remove any previous installation of _telegraf_.

. As _prog_:

.. Create the local configuration directory:

   cd /usr2/st
   mkdir telegraf.conf

.. Place the _README_ and _telefgraf.conf_ files in the directory.

+

A pointer to an example _README_ file and a listing of it is provided
in the appendix <<README file>>.

+

+

A pointer to an example _telegraf.conf_ file for _fs1_ and a listing
of it is provided in the appendix <<fs1 telegraf.conf file>>.

+

NOTE: If you are using the directions to install _telegraf_ on _fs2_,
a pointer an example file for that machine and a listing of it are
provided in the appendix <<fs2 telegraf.conf file>>.

+

+

NOTE: If all of the devices covered in the example _telegraf.conf_ file
are not available for your system, you may want to install an
abbreviated version. This could be setup to only access the computer
performance information and, optionally, some sub-set of the other
devices. You can edit the _telegraf.conf_ file for the features you
want. The example in the appendix <<fs1 telegraf.conf.partial file>>
could be used for comparison. It could also be used as is, if its name
is changed to _telegraf.conf_. You can use the example in
<<fs2 telegraf.conf.partial file>> for comparison if you are working
on _fs2_.

. As _root_:

..  Add aliases to _/etc/hosts_ for the datalogger as
`datalog`; for the MAS, as `mas`.

.. Execute (cut-and-paste will work for the wrapped second line):

    cd ~
    wget https://github.com/nvi-inc/telegraf/releases/download/v1.14.2-vlbi-0.5.2/telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    dpkg -i telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    cp /usr2/st/telegraf.conf/telegraf.conf /etc/telegraf

+

TIP: For the _cp_ command, you may be prompted to confirm
overwritting _/etc/telegraf/telegraf.conf_. It should be safe to
answer `*y*`.

+

CAUTION: The configuration file is already set with the alias, `12m`,
for the 12m antenna. If this does not agree with _/etc/hosts_, one or
the other should be corrected.

+

CAUTION: The `metserver` (_metserver_ or _gromet_) host in the
configuration files is by default set to the `127.0.0.1` for the case
of the `metserver` serving to the local host only. If it serves to the
network, use an alias for _fs1_ (for files on _fs2_, use an alias for
_fs2_) from _/etc/hosts_ instead. If you don't have a `metserver`, you
could comment out the `metserver` lines.

..  Set the _telegraf_ user name and password in
 _/etc/telegraf/telegraf.conf_ (_not_ in the copy in
 _/usr2/st/telegraf.conf_).

.. Execute:

    systemctl restart telegraf

+

NOTE: _telegraf_ is ``enable``d by default, so it will start
automatically after a reboot.

=== Testing telegraf on fs1

. Verify that there are no errors for communication with the antenna
by the FS and the ACI program.

+

If there are errors, disable _telegraf_ antenna access, as _root_:

.. Edit _/etc/telegraf.conf_ and comment out the block:

    [[inputs.modbus_antenna]]
    ## modbus antenna controller type
    antenna_type = "intertronics12m"
    ## network address in form ip:port
    address = "12m:502"

.. Execute:

    systemctl restart telegraf


. [[no_problems]]<<no_problems,Verify there are no other problems>>:

.. Check in _grafana_ on the MAS to see if the antenna (if antenna
access wasn't disabled) and met. data are updating.

.. A minimal test with the FS to assure that things are working would
include:

... A quick pointing check, which should be nominal and should not
have communication errors with the antenna.

+

... If _gromet_ (or _metserver_) is in use, try he `wx` command to
verify met data is still available.

== fs2 installation

Once _fs1_ has been successfully set-up, the _fs2_ disks, running in
the spare computer, can be set-up.  Do not proceed with this step until
_telegraf_ is working on _fs1_.

=== Preparing fs2

NOTE: If you are combining the _gromet_ and _telegraf_ installations
and have _not_ restored the RAIDs as part of the _gromet_
installation, you should skip this step. Instead proceed to the next
step, <<Changes needed before installing telegraf on fs2>>, below.

Follow the instructions in in the <<Preparing fs1>> section above, but
this time doing them on _fs2_. Then continue with next step,
<<Changes needed before installing telegraf on fs2>>, below.

=== Changes needed before installing telegraf on fs2

For this part of the installation it will be necessary to take some additional steps:

. Terminate the FS on _fs1_.

. Stop _telegraf_, _metclient_, and _gromet_ (or _metserver_ if it
being used instead of _gromet_) on _fs1_, as _root_, where _server_
is either `gromet` or `metserver`:

+

[subs="+quotes"]
....
systemctl stop telegraf
systemctl stop metclient
systemctl stop _server_
....

+

NOTE: If neither _gromet_ or _metserver_ is being used, omit the
`metclient` and _server_ commands. If _metclient_ is not being used,
omit the command for it.

. If _metserver_ is being used, Move the serial connectors for the
MET4A and wind sensors to the corresponding connectors on _fs2_.

. If _gromet_ (or _metserver_) is used on _fs2_:

.. Start it as _root_, where _server_ is either `gromet` or
`metserver`:

+

[subs="+quotes"]
....
systemctl start _server_
....

+

.. As _oper_, start the FS on _fs2_ and verify that met data is being
received with the command:

    wx

=== Installing telegraf on fs2

Follow the directions in the <<Installing telegraf on fs1>> section
above, but this time performing the steps on _fs2_.

NOTE: If _telegraf_ antenna access had to be disabled on _fs1_ to
eliminate communication errors, it is expected that this will be
needed on _fs2_ as well.

=== Testing telegraf on fs2

Follow the directions in the <<Testing telegraf on fs1>> section
above, but this time using _fs2_.

== Finishing up

The sections covers the steps to follow once _telegraf_ has been
tested successfully on _both_ _fs1_ and _fs2_ It will leave the
systems configured with _telegraf_ (and _gromet_ or _metserver_, if
they are being used) running on _fs1_ and not on _fs2_

=== Finalizing fs2

. Terminate the FS on _fs2_.

. Stop _telegraf_, _gromet_ (or _metserver_), and _metclient  on
_fs2_, as _root_ , where _server_ is either `gromet` or `metserver`:

+

[subs="+quotes"]
....
systemctl stop telegraf
systemctl stop metclient
systemctl stop _server_
....

+

NOTE: If neither _gromet_ or _metserver_ is being used, omit the
`metclient` and _server_ commands. If _metclient_ is not being used,
omit the command for it.


. Disable _telegraf_, _gromet_ (or _metserver_), and _metclient on
_fs2_, as _root_, where _server_ is either `gromet` or `metserver`:

+

[subs="+quotes"]
....
systemctl disable telegraf
systemctl disable metclient
systemctl disable _server_
....

+

NOTE: If neither _gromet_ or _metserver_ is being used, omit the
`metclient` and _server_ commands. If _metclient_ is not being used,
omit the command for it.

=== Finalizing fs1

. If _metserver_ is being used, move the serial connectors for the
MET4A and wind sensors to the original connectors on _fs1_.

. Start _gromet_ (or _metserver_), _telegraf_ and _metclient_ on
_fs1_, as _root_, where _server_ is either `gromet` or `metserver`:

+

[subs="+quotes"]
....
systemctl start _server_
systemctl start metclient
systemctl start telegraf
....

+

NOTE: If neither _gromet_ or _metserver_ is being used, omit the first
two commands.  If _metclient_ is not being used, omit the command for
it.

. Start the FS on _fs1_.

. Reverify the second step <<no_problems,Verify there are no other
problems>> in <<Testing telegraf on fs1>>

== Installing the set_telegraf utility

You may want to install the _set_telegraf_ script. This script can be
used by _root_ to change which machine _fs1_ or _fs2_ runs _telegraf_
for operations (and _gromet_). This works best when _gromet_, instead
of _metserver_ is used as the server for met. data. You can adjust the
steps for using _metserver_. Some notes on doing that are provided. If
you don't want to install _set_telegraf_, skip ahead to the
<<Restoring RAIDs>> step below.

The use of the _set_telegraf_ utility is described in the appendix
<<set_telegraf utility>>.

=== set_telegraf installation

The steps for installing _set_telegraf_ on _fs1_ and _fs2_ are almost
identical. The three differences are **NOTE**d in the steps of
<<fs1 set_telegraf installation>> below and summarized in
<<fs2 set_telegraf installation>> section below.

For the installation steps, use of _gromet_ is assumed. If it is not
being used, the _set_telegraf_ script on both machines will need to
have the _gromet_ steps removed or replaced with _metserver_ steps, as
appropriate. This is **NOTE**d in the sub-steps.

CAUTION: If _metserver_ is being used, it must have be setup on both
machines first. Additionally, when switching between machines, the
physical connections to the met. devices will need to moved between
the computers. When _gromet_ is used, switching the configuration is
an entirely software operation.

==== fs1 set_telegraf installation

These steps are performed on _fs1_.

NOTE: For installing on _fs2_, these steps are performed on _fs2_.

To install the _set_telegraf_ script, as _root_:

. Place a copy of _set_telegraf_ (a pointer to an example file and
listing of it is available in the appendix <<set_telegraf utility>>)
in _/usr/local/sbin/set_telegraf_

+

NOTE: If _gromet_ is _not_ being used, the _gromet_ lines in the
script will need to be changed as described in the *TIP* in the
<<set_telegraf installation>> step above.

+

NOTE: If _metclient_ is being used, the _metclient_ lines in the
script will need to be uncommented.

. Set ownerships and permissions:

  cd /usr/local/sbin
  chown root.root set_telegraf
  chmod u+rwx,go+r,go-wx, set_telegraf

. Save the existing _telegraf_ configuraton file:

  cd /etc/telegraf
  mkdir OLD
  mv telegraf.conf OLD

. Copy the _/etc/telegraf/OLD/telegraf.conf_ to _/etc/telegraf.conf.full_

  cd /etc/telegraf
  cp OLD/telegraf.conf telegraf.conf.full

. When working on _fs1_, place a copy of the _fs1_ version of
_telegraf.conf.partial_ (a pointer to an example and a listing of it
is provided in the appendix <<fs1 telegraf.conf.partial file>>) in
_/etc/telegraf/_.

+

TIP: You may want to update the address for the _metserver_ in
_telegraf.conf.partial_ to agree with your _telegraf.conf.full_.

+

[NOTE]
====

If you are using these directions to install on _fs2_, a pointer to an
example _telegraf.conf.partial_ for that machine and a listing of it
are provided in the appendix <<fs2 telegraf.conf.partial file>>.

TIP: You may want to update the address for the _metserver_ in
_telegraf.conf.partial_ to agree with your _telegraf.conf.full_.

====

. When working on _fs1_, create the symbolic link:

  cd /etc/telegraf
  ln -sfn telegraf.conf.full telegraf.conf

+

[IMPORTANT]
====

When working on _fs2_, instead, use:

  cd /etc/telegraf
  ln -sfn telegraf.conf.partial telegraf.conf
====

==== fs2 set_telegraf installation

The directions for _fs2_ are identical to the ones for _fs1_, except:

* All work is performed on _fs2_

* The information for the relevant _telegraf.conf.partial_ file is the
one in the appendix <<fs2 telegraf.conf.partial file>>

* The symbolic link is set to point to _telegraf.conf.partial_.

Please follow the directions in <<fs1 set_telegraf installation>> with
those changes, which are **NOTE**d there, then proceed to the step
<<Testing set_telegraf>> below.

=== Testing set_telegraf

The sub-steps below, on particular machines, alternately disable and
enable _telegraf_ from collecting antenna data, and met. data if met.
devices are being used.

CAUTION: Be careful to enter the command on the machine indicated.

. On _fs1_ as _root_, execute:

  set_telegraf partial

. Verify that the _grafana_ display is _not_ showing updating
antenna/met. data.

. On _fs2_ as _root_, execute:

  set_telegraf full

. Verify that the _grafana_ display is showing updating antenna/met.
data.

. On _fs2_ as _root_, execute:

  set_telegraf partial

. Verify that the _grafana_ display is _not_ showing updating
antenna/met. data.

. On _fs1_ as _root_, execute:

  set_telegraf full

. Verify that the _grafana_ display is showing updating antenna/met.
data.

If in each case _grafana_ was showing or not showing the data as
indicated, then the system is checked out and has been returned to the
operational _telegraf_ being on _fs1_. The _telegraf_ on _fs2_ should
still be collecting diagnostic information for that computer. This is
the normal configuration.

== Restoring RAIDs

If everything is still working, follow the _successful_ steps in the
recoverable test procedure, to recover the RAIDs on both _fs1_ and
_fs2_:

https://nvi-inc.github.io/fsl10/raid.html#_recoverable_testing

. Recover the RAID on _fs1_.

. Recover the RAID on _fs2_.

[appendix]

= README file

An example can be found in the file _README_ at:
https://github.com/nvi-inc/telegraf_install. A listing is provided
below.

....
install:

  root:
    cd ~
    wget https://github.com/nvi-inc/telegraf/releases/download/v1.14.2-vlbi-0.5.2/telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    dpkg -i telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    mkdir /etc/telegraf
    cp /usr2/st/telegraf.conf/telegraf.conf /etc/telegraf
      (you may need to change which FS version is pinned)
    systemctl restart telegraf
....

[appendix]

= set_telegraf utility

This appendix provides information on the use of the _set_telegraf_
utility, a pointer to an example version, and a listing of it. These
points are covered in sub-sections below. Its installation is covered
in the section <<Installing the set_telegraf utility>> above.

=== Use of set_telegraf

The _set_telegraf_ utility provides a command that can be used to
switch the configuration of _telegraf_ on the _operational_ and
_spare_ computer systems. The _telegraf_ configuration on operational
system is usually the _full_ configuration, collecting data from the
antenna, FS, datalogger, and met. server, as well as the performance
data for that computer. The configuration on the spare computer is the
_partial_ configuration. It only collects the performance data for
that computer. If for some reason the usual operational disks (_fs1_)
can't be used (in either the operational or spare computer chassis)
and spare disks (_fs2_) are pressed into service for operations,
_set_telegraf_ provides a means to change the telegraf configuration
on the spare dsks into the operational one, and vice-versa.

NOTE: The node names of the systems are associated with the disks, not
the computer chassis. Thus if the _fs1_ disks are moved from the usual
operational computer chassis to the spare computer chassis, then _fs1_
is running in the spare computer chassis. If the _fs1_ disks are moved
to the spare chassis, they can still be used for operations, including
using the full _telegraf_ configuration.

IMPORTANT: It is important that only one _telegraf_ configuration be
the full one at any given time. As a result, you should always change
the current full configuration to partial before enabling the full
configuration on the other computer. If it is not possible to disable
the current full configuration (for exaample the disks won't boot)
before enabling the other, the system with the previous full
configuration should be kept off the network until it has been
switched to partial. This can be done either be keeping it turned off
or disconnected from the network.

. To switch the full configuration from _fs1_ to _fs2_:

.. Change the _telegraf_ on the _fs1_ disks to `partial`, as _root_:

   set_telegraf partial

.. Change the _telegraf_ on the _fs2_ disks to `full`, as _root_:

   set_telegraf full

.. If _gromet_ (or _metserver_) was serving data to the network
instead of the local host, then:

... You will need to adjust all other systems that were getting met.
data from _fs1_ to point to _fs2_ instead.

... If this is the first time you have switched to using `full` on
_fs2_ since the last _refresh_spare_usr2_, then on _fs2_ you will need
to:

.... As _oper_, change _/usr2/control/equip.ctl_ to point to _fs2_ for
the met. data.

.... If you are using _metclient_, you will need to:

..... As _prog_, change the `HOST` in
_/usr2/st/metclient/metclient_systemd.sh_ to point to _fs2_.

..... As _root_, execute:

    systemctl restart metclient

When operations can be restored to the _fs1_ computer, switch the
systems back:

. To switch the full configuration from _fs2_ to _fs1_:

.. Change the _telegraf_ on the _fs2_ disks to `partial`, as _root_:

   set_telegraf partial

.. Change the _telegraf_ on the _fs1_ disks to `full`, as _root_:

   set_telegraf full

.. If _gromet_ (or _metserver_) was serving data to the network
instead of the local host, then:

... You will need to adjust all other systems that were getting met.
data from _fs2_ to point to _fs1_ instead.

=== set_telegraf script

An example script can be found in the file _set_telegraf_ at:
https://github.com/nvi-inc/telegraf_install. A listing is provided
below.

....
#!/bin/bash
set -e

usage() {
cat <<EOF

  Usage: `basename "$0"` [options] command
  Configure 12m FS computer telegraf/gromet

  command is full or partial

  if no command then current state is shown.

  Options:
   -f   force change if state is unknown or already in that state
        (use with care, may cause problems)
   -h   print this message
EOF
}

if ! [ $(id -u) = 0 ]; then
  echo "This script must be run as root."
  exit 1
fi

file=$(readlink -f /etc/telegraf/telegraf.conf)
if [[ "$file" =~ ^/etc/telegraf/telegraf.conf.full$ ]]; then
   state=full
elif [[ "$file" =~ ^/etc/telegraf/telegraf.conf.partial$ ]]; then
   state=partial
else
   state=unknown
fi

force=
while getopts 'fh' opt; do
    case $opt in
        f)
            force=1
            ;;
        h)
            usage
            exit 0
            ;;
        *)
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))

if [[ $# -eq 0 ]] ; then
    echo "state is $state"
    exit 0
fi

cmd=$1

if [[ ! "$cmd" =~ ^(full|partial)$ ]]; then
   echo "command must be full or partial, was: $cmd"
   exit 1
fi

if [[ "$state" =~ "$cmd" ]]; then
    if [[ -z "$force" ]] ; then
        echo "already in $state, use -f to force recommanding"
        exit 1
     fi
fi

if [[ "$state" =~ "unknown" ]]; then
    if [[ -z "$force" ]] ; then
         echo "Can't change unknown state without -f"
         exit 1
    fi
fi


if [[ "$cmd" =~ ^full$ ]]; then
    echo -n "  Did you set the other computer to partial first? (y=yes, n=no) : "
    badans=true
    while [ "$badans" = "true" ]
    do
      read ans
      case "$ans" in
        y|yes) echo "  O.K. Setting to full ... "
               badans=false
               ;;
        n|no)  echo "  Please do that first."
               exit
               ;;
        *)     echo -n "  Please answer with y=yes or n=no : "
      esac
    done

    echo "  Starting gromet"
    systemctl start gromet

    echo "  Enabling gromet"
    systemctl enable gromet

#    echo "  Starting metclient"
#    systemctl start metclient

#    echo "  Enabling metclient"
#    systemctl enable metclient

    echo "  Changing directory to /etc/telegraf"
    cd /etc/telegraf

    echo "  Linking telegraf.conf to telegraf.conf.full"
    ln -sfn telegraf.conf.full telegraf.conf

    echo "  Restarting telegraf"
    systemctl restart telegraf
else
    echo "  Setting to partial ..."

#    echo "  Stopping metclient"
#    systemctl stop metclient

#    echo "  Disabling metclient"
#    systemctl disable metclient

    echo "  Stopping gromet"
    systemctl stop gromet

    echo "  Disabling gromet"
    systemctl disable gromet

    echo "  Changing directory to /etc/telegraf"
    cd /etc/telegraf

    echo "  Linking telegraf.conf to telegraf.conf.partial"
    ln -fsn telegraf.conf.partial telegraf.conf

    echo "  Restarting telegraf"
    systemctl restart telegraf
fi

echo "  Done."
....

[appendix]

= fs1 telegraf.conf file

An example can be found in the file _fs1/telegraf.conf_ at:
https://github.com/nvi-inc/telegraf_install. A listing is provided
below.

....
# Telegraf Configuration
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply surround
# them with ${}. For strings the variable must be within quotes (ie, "${STR_VAR}"),
# for numbers and booleans they should be plain (ie, ${INT_VAR}, ${BOOL_VAR})


# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "10s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s.
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
  precision = ""

  ## Log at debug level.
  # debug = true
  debug = false
  ## Log only error level messages.
  quiet = false

  ## Log file name, the empty string means to log to stderr.
  #logfile = "/tmp/telegraf.log"
  logfile = ""

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # logfile_rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Override default hostname, if empty use os.Hostname()
  hostname = ""
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################


# Send telegraf metrics to file(s)
#[[outputs.file]]
  ## Files to write to, "stdout" is a specially handled file.
  # files = ["/tmp/metrics.out"]

  ## The file will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # rotation_max_archives = 5

  ## Data format to output.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
  # data_format = "influx"

# Configuration for sending metrics to InfluxDB
[[outputs.influxdb]]
  ## The full HTTP or UDP URL for your InfluxDB instance.
  ##
  ## Multiple URLs can be specified for a single cluster, only ONE of the
  ## urls will be written to each interval.
  # urls = ["unix:///var/run/influxdb.sock"]
  # urls = ["udp://127.0.0.1:8089"]
  urls = ["http://mas:8086"]

  ## The target database for metrics; will be created as needed.
  database = "ops"

  ## If true, no CREATE DATABASE queries will be sent.  Set to true when using
  ## Telegraf with a user without permissions to create databases or when the
  ## database already exists.
  skip_database_creation = true

  ## Name of existing retention policy to write to.  Empty string writes to
  ## the default retention policy.  Only takes effect when using HTTP.
  # retention_policy = ""

  ## Write consistency (clusters only), can be: "any", "one", "quorum", "all".
  ## Only takes effect when using HTTP.
  # write_consistency = "any"

  ## Timeout for HTTP messages.
  # timeout = "5s"

  ## HTTP Basic Auth
  # dummy values
  # username = "something"
  # password = "something_else"
    username = "something"
    password = "something_else"

  ## HTTP User-Agent
  # user_agent = "telegraf"

  ## UDP payload size is the maximum packet size to send.
  # udp_payload = "512B"

  ## Optional TLS Config for use on HTTP connections.
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false

  ## HTTP Proxy override, if unset values the standard proxy environment
  ## variables are consulted to determine which proxy, if any, should be used.
  # http_proxy = "http://corporate.proxy:3128"

  ## Additional HTTP headers
  # http_headers = {"X-Special-Header" = "Special-Value"}

  ## HTTP Content-Encoding for write request body, can be set to "gzip" to
  ## compress body or "identity" to apply no encoding.
  # content_encoding = "identity"

  ## When true, Telegraf will output unsigned integers as unsigned values,
  ## i.e.: "42u".  You will need a version of InfluxDB supporting unsigned
  ## integer values.  Enabling this option will result in field type errors if
  ## existing data has been written.
  # influx_uint_support = false


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Read metrics about disk usage
[[inputs.disk]]
ignore_fs = ["tmpfs", "devtmpfs"]

# Read metrics about disk IO by device
[[inputs.diskio]]
  ## By default, telegraf will gather stats for all devices including
  ## disk partitions.
  ## Setting devices will restrict the stats to the specified devices.
  # devices = ["sda", "sdb"]
  ## Uncomment the following line if you need disk serial numbers.
  # skip_serial_number = false


# Get kernel statistics from /proc/stat
[[inputs.kernel]]
  # no configuration

# Get the number of processes and group them by status
[[inputs.processes]]
  # no configuration

# Read metrics about swap memory usage
[[inputs.swap]]
  # no configuration

# Read metrics about system load & uptime
[[inputs.system]]
  # no configuration

# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics.
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states.
  report_active = false


# Query Delphin data logger configured from MGO
[[inputs.delphin_datalogger]]
# Address and port of datalogger modbus port
address = "datalog"
port = 502
timeout = "20s"
slave_id = 1


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Query an antenna controller using modbus over TCP. Registers are assumed to be 32bits wide.
[[inputs.modbus_antenna]]
### modbus antenna controller type
antenna_type = "intertronics12m"
### network address in form ip:port
address = "12m:502"

# Query at MET4 meteorological measurement systems via metserver
[[inputs.met4]]
  ## Address of metserver
  address = "127.0.0.1:50001"
#  address = "fs1:50001"
  ## You can add extra tags, for example
  # [inputs.met4.tags]
  #     location = "..."
  #     device = "old"


###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################


# Poll the Field System state through shared memory.
[[inputs.fieldsystem]]
## Poll the Field System state through shared memory.
##
## Record RDBE Tsys and Pcal calculated by FS.
## This complements the rdbe_multicast input.
rdbe = true
## Rate to poll FS variables.
#precision = "100ms"
version = "10.0.0-beta1"
....

[appendix]

= fs1 telegraf.conf.partial file

An example can be found in the file _fs1/telegraf.conf.partial_ at:
https://github.com/nvi-inc/telegraf_install. A listing is provided
below.

....
# Telegraf Configuration
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply surround
# them with ${}. For strings the variable must be within quotes (ie, "${STR_VAR}"),
# for numbers and booleans they should be plain (ie, ${INT_VAR}, ${BOOL_VAR})


# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "10s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s.
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
  precision = ""

  ## Log at debug level.
  # debug = true
  debug = false
  ## Log only error level messages.
  quiet = false

  ## Log file name, the empty string means to log to stderr.
  #logfile = "/tmp/telegraf.log"
  logfile = ""

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # logfile_rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Override default hostname, if empty use os.Hostname()
  hostname = ""
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################


# Send telegraf metrics to file(s)
#[[outputs.file]]
  ## Files to write to, "stdout" is a specially handled file.
  # files = ["/tmp/metrics.out"]

  ## The file will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # rotation_max_archives = 5

  ## Data format to output.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
  # data_format = "influx"

# Configuration for sending metrics to InfluxDB
[[outputs.influxdb]]
  ## The full HTTP or UDP URL for your InfluxDB instance.
  ##
  ## Multiple URLs can be specified for a single cluster, only ONE of the
  ## urls will be written to each interval.
  # urls = ["unix:///var/run/influxdb.sock"]
  # urls = ["udp://127.0.0.1:8089"]
  urls = ["http://mas:8086"]

  ## The target database for metrics; will be created as needed.
  database = "ops"

  ## If true, no CREATE DATABASE queries will be sent.  Set to true when using
  ## Telegraf with a user without permissions to create databases or when the
  ## database already exists.
  skip_database_creation = true

  ## Name of existing retention policy to write to.  Empty string writes to
  ## the default retention policy.  Only takes effect when using HTTP.
  # retention_policy = ""

  ## Write consistency (clusters only), can be: "any", "one", "quorum", "all".
  ## Only takes effect when using HTTP.
  # write_consistency = "any"

  ## Timeout for HTTP messages.
  # timeout = "5s"

  ## HTTP Basic Auth
  # dummy values
  # username = "something"
  # password = "something_else"
    username = "something"
    password = "something_else"

  ## HTTP User-Agent
  # user_agent = "telegraf"

  ## UDP payload size is the maximum packet size to send.
  # udp_payload = "512B"

  ## Optional TLS Config for use on HTTP connections.
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false

  ## HTTP Proxy override, if unset values the standard proxy environment
  ## variables are consulted to determine which proxy, if any, should be used.
  # http_proxy = "http://corporate.proxy:3128"

  ## Additional HTTP headers
  # http_headers = {"X-Special-Header" = "Special-Value"}

  ## HTTP Content-Encoding for write request body, can be set to "gzip" to
  ## compress body or "identity" to apply no encoding.
  # content_encoding = "identity"

  ## When true, Telegraf will output unsigned integers as unsigned values,
  ## i.e.: "42u".  You will need a version of InfluxDB supporting unsigned
  ## integer values.  Enabling this option will result in field type errors if
  ## existing data has been written.
  # influx_uint_support = false


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Read metrics about disk usage
[[inputs.disk]]
ignore_fs = ["tmpfs", "devtmpfs"]

# Read metrics about disk IO by device
[[inputs.diskio]]
  ## By default, telegraf will gather stats for all devices including
  ## disk partitions.
  ## Setting devices will restrict the stats to the specified devices.
  # devices = ["sda", "sdb"]
  ## Uncomment the following line if you need disk serial numbers.
  # skip_serial_number = false


# Get kernel statistics from /proc/stat
[[inputs.kernel]]
  # no configuration

# Get the number of processes and group them by status
[[inputs.processes]]
  # no configuration

# Read metrics about swap memory usage
[[inputs.swap]]
  # no configuration

# Read metrics about system load & uptime
[[inputs.system]]
  # no configuration

# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics.
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states.
  report_active = false


# Query Delphin data logger configured from MGO
#[[inputs.delphin_datalogger]]
# Address and port of datalogger modbus port
#address = "datalog"
#port = 502
#timeout = "20s"
#slave_id = 1


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Query an antenna controller using modbus over TCP. Registers are assumed to be 32bits wide.
#[[inputs.modbus_antenna]]
### modbus antenna controller type
#antenna_type = "intertronics12m"
### network address in form ip:port
#address = "12m:502"

# Query at MET4 meteorological measurement systems via metserver
#[[inputs.met4]]
#  ## Address of metserver
#  address = "127.0.0.1:50001"
##  address = "fs1:50001"
#  ## You can add extra tags, for example
#  # [inputs.met4.tags]
#  #     location = "..."
#  #     device = "old"


###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################


# Poll the Field System state through shared memory.
#[[inputs.fieldsystem]]
## Poll the Field System state through shared memory.
##
## Record RDBE Tsys and Pcal calculated by FS.
## This complements the rdbe_multicast input.
#rdbe = true
## Rate to poll FS variables.
#precision = "100ms"
#version = "10.0.0-beta1"
....

[appendix]

= fs2 telegraf.conf file

An example can be found in the file _fs2/telegraf.conf_ at:
https://github.com/nvi-inc/telegraf_install. A listing is provided
below.

....
# Telegraf Configuration
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply surround
# them with ${}. For strings the variable must be within quotes (ie, "${STR_VAR}"),
# for numbers and booleans they should be plain (ie, ${INT_VAR}, ${BOOL_VAR})


# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "10s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s.
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
  precision = ""

  ## Log at debug level.
  # debug = true
  debug = false
  ## Log only error level messages.
  quiet = false

  ## Log file name, the empty string means to log to stderr.
  #logfile = "/tmp/telegraf.log"
  logfile = ""

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # logfile_rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Override default hostname, if empty use os.Hostname()
  hostname = ""
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################


# Send telegraf metrics to file(s)
#[[outputs.file]]
  ## Files to write to, "stdout" is a specially handled file.
  # files = ["/tmp/metrics.out"]

  ## The file will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # rotation_max_archives = 5

  ## Data format to output.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
  # data_format = "influx"

# Configuration for sending metrics to InfluxDB
[[outputs.influxdb]]
  ## The full HTTP or UDP URL for your InfluxDB instance.
  ##
  ## Multiple URLs can be specified for a single cluster, only ONE of the
  ## urls will be written to each interval.
  # urls = ["unix:///var/run/influxdb.sock"]
  # urls = ["udp://127.0.0.1:8089"]
  urls = ["http://mas:8086"]

  ## The target database for metrics; will be created as needed.
  database = "ops"

  ## If true, no CREATE DATABASE queries will be sent.  Set to true when using
  ## Telegraf with a user without permissions to create databases or when the
  ## database already exists.
  skip_database_creation = true

  ## Name of existing retention policy to write to.  Empty string writes to
  ## the default retention policy.  Only takes effect when using HTTP.
  # retention_policy = ""

  ## Write consistency (clusters only), can be: "any", "one", "quorum", "all".
  ## Only takes effect when using HTTP.
  # write_consistency = "any"

  ## Timeout for HTTP messages.
  # timeout = "5s"

  ## HTTP Basic Auth
  # dummy values
  # username = "something"
  # password = "something_else"
    username = "something"
    password = "something_else"

  ## HTTP User-Agent
  # user_agent = "telegraf"

  ## UDP payload size is the maximum packet size to send.
  # udp_payload = "512B"

  ## Optional TLS Config for use on HTTP connections.
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false

  ## HTTP Proxy override, if unset values the standard proxy environment
  ## variables are consulted to determine which proxy, if any, should be used.
  # http_proxy = "http://corporate.proxy:3128"

  ## Additional HTTP headers
  # http_headers = {"X-Special-Header" = "Special-Value"}

  ## HTTP Content-Encoding for write request body, can be set to "gzip" to
  ## compress body or "identity" to apply no encoding.
  # content_encoding = "identity"

  ## When true, Telegraf will output unsigned integers as unsigned values,
  ## i.e.: "42u".  You will need a version of InfluxDB supporting unsigned
  ## integer values.  Enabling this option will result in field type errors if
  ## existing data has been written.
  # influx_uint_support = false


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Read metrics about disk usage
[[inputs.disk]]
ignore_fs = ["tmpfs", "devtmpfs"]

# Read metrics about disk IO by device
[[inputs.diskio]]
  ## By default, telegraf will gather stats for all devices including
  ## disk partitions.
  ## Setting devices will restrict the stats to the specified devices.
  # devices = ["sda", "sdb"]
  ## Uncomment the following line if you need disk serial numbers.
  # skip_serial_number = false


# Get kernel statistics from /proc/stat
[[inputs.kernel]]
  # no configuration

# Get the number of processes and group them by status
[[inputs.processes]]
  # no configuration

# Read metrics about swap memory usage
[[inputs.swap]]
  # no configuration

# Read metrics about system load & uptime
[[inputs.system]]
  # no configuration

# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics.
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states.
  report_active = false


# Query Delphin data logger configured from MGO
[[inputs.delphin_datalogger]]
# Address and port of datalogger modbus port
address = "datalog"
port = 502
timeout = "20s"
slave_id = 1


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Query an antenna controller using modbus over TCP. Registers are assumed to be 32bits wide.
[[inputs.modbus_antenna]]
### modbus antenna controller type
antenna_type = "intertronics12m"
### network address in form ip:port
address = "12m:502"

# Query at MET4 meteorological measurement systems via metserver
[[inputs.met4]]
  ## Address of metserver
  address = "127.0.0.1:50001"
#  address = "fs2:50001"
  ## You can add extra tags, for example
  # [inputs.met4.tags]
  #     location = "..."
  #     device = "old"


###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################


# Poll the Field System state through shared memory.
[[inputs.fieldsystem]]
## Poll the Field System state through shared memory.
##
## Record RDBE Tsys and Pcal calculated by FS.
## This complements the rdbe_multicast input.
rdbe = true
## Rate to poll FS variables.
#precision = "100ms"
version = "10.0.0-beta1"
....

[appendix]

= fs2 telegraf.conf.partial file

An example can be found in the file _fs2/telegraf.conf.partial_ at:
https://github.com/nvi-inc/telegraf_install. A listing is provided
below.
....
# Telegraf Configuration
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply surround
# them with ${}. For strings the variable must be within quotes (ie, "${STR_VAR}"),
# for numbers and booleans they should be plain (ie, ${INT_VAR}, ${BOOL_VAR})


# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "10s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s.
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
  precision = ""

  ## Log at debug level.
  # debug = true
  debug = false
  ## Log only error level messages.
  quiet = false

  ## Log file name, the empty string means to log to stderr.
  #logfile = "/tmp/telegraf.log"
  logfile = ""

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # logfile_rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Override default hostname, if empty use os.Hostname()
  hostname = ""
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################


# Send telegraf metrics to file(s)
#[[outputs.file]]
  ## Files to write to, "stdout" is a specially handled file.
  # files = ["/tmp/metrics.out"]

  ## The file will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # rotation_max_archives = 5

  ## Data format to output.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
  # data_format = "influx"

# Configuration for sending metrics to InfluxDB
[[outputs.influxdb]]
  ## The full HTTP or UDP URL for your InfluxDB instance.
  ##
  ## Multiple URLs can be specified for a single cluster, only ONE of the
  ## urls will be written to each interval.
  # urls = ["unix:///var/run/influxdb.sock"]
  # urls = ["udp://127.0.0.1:8089"]
  urls = ["http://mas:8086"]

  ## The target database for metrics; will be created as needed.
  database = "ops"

  ## If true, no CREATE DATABASE queries will be sent.  Set to true when using
  ## Telegraf with a user without permissions to create databases or when the
  ## database already exists.
  skip_database_creation = true

  ## Name of existing retention policy to write to.  Empty string writes to
  ## the default retention policy.  Only takes effect when using HTTP.
  # retention_policy = ""

  ## Write consistency (clusters only), can be: "any", "one", "quorum", "all".
  ## Only takes effect when using HTTP.
  # write_consistency = "any"

  ## Timeout for HTTP messages.
  # timeout = "5s"

  ## HTTP Basic Auth
  # dummy values
  # username = "something"
  # password = "something_else"
    username = "something"
    password = "something_else"

  ## HTTP User-Agent
  # user_agent = "telegraf"

  ## UDP payload size is the maximum packet size to send.
  # udp_payload = "512B"

  ## Optional TLS Config for use on HTTP connections.
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false

  ## HTTP Proxy override, if unset values the standard proxy environment
  ## variables are consulted to determine which proxy, if any, should be used.
  # http_proxy = "http://corporate.proxy:3128"

  ## Additional HTTP headers
  # http_headers = {"X-Special-Header" = "Special-Value"}

  ## HTTP Content-Encoding for write request body, can be set to "gzip" to
  ## compress body or "identity" to apply no encoding.
  # content_encoding = "identity"

  ## When true, Telegraf will output unsigned integers as unsigned values,
  ## i.e.: "42u".  You will need a version of InfluxDB supporting unsigned
  ## integer values.  Enabling this option will result in field type errors if
  ## existing data has been written.
  # influx_uint_support = false


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Read metrics about disk usage
[[inputs.disk]]
ignore_fs = ["tmpfs", "devtmpfs"]

# Read metrics about disk IO by device
[[inputs.diskio]]
  ## By default, telegraf will gather stats for all devices including
  ## disk partitions.
  ## Setting devices will restrict the stats to the specified devices.
  # devices = ["sda", "sdb"]
  ## Uncomment the following line if you need disk serial numbers.
  # skip_serial_number = false


# Get kernel statistics from /proc/stat
[[inputs.kernel]]
  # no configuration

# Get the number of processes and group them by status
[[inputs.processes]]
  # no configuration

# Read metrics about swap memory usage
[[inputs.swap]]
  # no configuration

# Read metrics about system load & uptime
[[inputs.system]]
  # no configuration

# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics.
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states.
  report_active = false


# Query Delphin data logger configured from MGO
#[[inputs.delphin_datalogger]]
# Address and port of datalogger modbus port
#address = "datalog"
#port = 502
#timeout = "20s"
#slave_id = 1


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Query an antenna controller using modbus over TCP. Registers are assumed to be 32bits wide.
#[[inputs.modbus_antenna]]
### modbus antenna controller type
#antenna_type = "intertronics12m"
### network address in form ip:port
#address = "12m:502"

# Query at MET4 meteorological measurement systems via metserver
#[[inputs.met4]]
#  ## Address of metserver
#  address = "127.0.0.1:50001"
##  address = "fs2:50001"
#  ## You can add extra tags, for example
#  # [inputs.met4.tags]
#  #     location = "..."
#  #     device = "old"


###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################


# Poll the Field System state through shared memory.
#[[inputs.fieldsystem]]
## Poll the Field System state through shared memory.
##
## Record RDBE Tsys and Pcal calculated by FS.
## This complements the rdbe_multicast input.
#rdbe = true
## Rate to poll FS variables.
#precision = "100ms"
#version = "10.0.0-beta1"
....
