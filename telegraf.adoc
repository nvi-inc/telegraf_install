//
// Copyright (c) 2020 NVI, Inc.
//
// This file is part of the FSL10 Linux distribution.
// (see http://github.com/nvi-inc/fsl10).
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
//

= DRAFT telgraf change request for KPGO 12m
E. Himwich, C. Frock, C. Coughlin
Version 0.2 - October 2020

:sectnums:
:experimental:
:downarrow: &downarrow;

:toc:
== Introduction

This document lays out the plan for installing `telegraf` (a collector
for the MAS) for the KPGO 12m Field System computers.  The resulting
configuration will be the same as is used at MGO.  `Telegraf` should
be installed on both *fs1* and *fs2*. The one on *fs1* is the nominal
operational installation. The one on *fs2* is there in case operations
have to move to the *fs2* disks. It should be disabled on *fs2* until
it is needed.


The installation process uses the "Recoverable test" procedure of
FSL10 to enable easy recovery in case of a problem. This has the
advantage that if (i) steps are missing from the procedure or (ii)
errors occur, and either or both can't be recovered from directly, it
is relatively easy to return to the original state and start over.

== Preparation

Working on the 12m *fs1* computer:

. Follow the directions for the recoverable test process at:

+
https://nvi-inc.github.io/fsl10/raid.html#_recoverable_testing
+
[NOTE]
====
If the systems at KPGO have not had the *drop_primary* script
installed yet, use the following command in its place:

    mdadm /dev/md0 -f /dev/sda2
====

. Once the primary disk has been dropped from the RAID, move onto the
next section. Later after testing has deemed to have been *successful*
or *failed*, or needs to be aborted, the appropriate ending branch of
the recoverable testing procedure should be used (see <<Finishing-up>>
below)

== Installing telegraf

Working on the 12m *fs1* computer:

. Remove any previous installation of `telegraf`.

. As `prog`:

.. Create the local configuration directory on fs1:

+
   cd /usr2/st
   mkdir telegraf.conf

.. Place the `README` file, listed in <<Appendix A. README file>>, in the directory.

.. Place the `telefgraf.conf` file, listed in <<Appendix B. telegraf.conf>>, in the directory.

. As `root` (cut-and-paste will work for the wrapped second line):

    cd ~
    wget https://github.com/nvi-inc/telegraf/releases/download/v1.14.2-vlbi-0.5.2/telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    dpkg -i telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    cp /usr2/st/telegraf/telegraf.conf /etc/telegraf
    systemctl restart telegraf
+
NOTE: The configuration file is already set with the correct alias, `12m`, for
the 12m antenna. The metserver host is also properly set as `127.0.0.1`, the local host.


. Verify that there are no errors for communication with the antenna by the FS and the ACI program.
+
If there are errors, disable `telegraf` antenna access:
+
.. Edit `/etc/telegraf.conf` and comment out the block:
+

    [[inputs.modbus_antenna]]
    ## modbus antenna controller type
    antenna_type = "intertronics12m"
    ## network address in form ip:port
    address = "12m:502"
+
.. Execute:
+

    systemctl restart telegraf


. Verify there are no problems:

.. Check in `grafana` on the MAS to see if the antenna and met. data are updating.
+
.. A minimal test with the FS to assure that things are working would include:

+

... A pointing check, which should not be abnormal and should not have communication errors with the antenna.

+

... Using the `wx` command to verify met data is still available.

. [[Finishing-up]]Finishing up

+

Assess whether any additional steps taken beyond what was described
above may cause problems. If so, they will need to be addressed.

.. If there are issues that can't be resolve before the system needs
to be used for operations, the test can be aborted by following the
*failed* branch of:
+
https://nvi-inc.github.io/fsl10/raid.html#_recoverable_testing
+
When ready, the testing can be restarted beginning with the
<<Preparation>> section above,

.. If and when everything is working, finalize the installation by following the *successful* branch of:
+
https://nvi-inc.github.io/fsl10/raid.html#_recoverable_testing

== Setting-up fs2

Once *fs1* has been successfully set-up, a truncated version of the
same process can be followed for installing `telegraf` on *fs2*.
Working with *fs2*, follow the steps in the <<Preparation>> and
<<Installing telegraf>> sections. In the latter, stop after step 3 (as
`root`) and then as `root` execute:

     systemctl disable telegraf
     systemctl stop telegraf

Then finish with step 6.b in <<Finishing-up>>.

== Appendix A. README file

....
install:

  root:
    cd ~
    wget https://github.com/nvi-inc/telegraf/releases/download/v1.14.2-vlbi-0.5.2/telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    dpkg -i telegraf-vlbi_1.14.2.vlbi.0.5.2-1_amd64.deb
    cp /usr2/st/telegraf.conf/telegraf.conf /etc/telegraf
      (you may need to change which FS version is pinned)
    systemctl restart telegraf
....

== Appendix B. telegraf.conf

....
# Telegraf Configuration
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply surround
# them with ${}. For strings the variable must be within quotes (ie, "${STR_VAR}"),
# for numbers and booleans they should be plain (ie, ${INT_VAR}, ${BOOL_VAR})


# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "10s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s.
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  ## Valid time units are "ns", "us" (or "Âµs"), "ms", "s".
  precision = ""

  ## Log at debug level.
  # debug = true
  debug = false
  ## Log only error level messages.
  quiet = false

  ## Log file name, the empty string means to log to stderr.
  #logfile = "/tmp/telegraf.log"
  logfile = ""

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # logfile_rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Override default hostname, if empty use os.Hostname()
  hostname = ""
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################


# Send telegraf metrics to file(s)
#[[outputs.file]]
  ## Files to write to, "stdout" is a specially handled file.
  # files = ["/tmp/metrics.out"]

  ## The file will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.
  # rotation_interval = "0d"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # rotation_max_archives = 5

  ## Data format to output.
  ## Each data format has its own unique set of configuration options, read
  ## more about them here:
  ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
  # data_format = "influx"

# Configuration for sending metrics to InfluxDB
[[outputs.influxdb]]
  ## The full HTTP or UDP URL for your InfluxDB instance.
  ##
  ## Multiple URLs can be specified for a single cluster, only ONE of the
  ## urls will be written to each interval.
  # urls = ["unix:///var/run/influxdb.sock"]
  # urls = ["udp://127.0.0.1:8089"]
  urls = ["http://mas:8086"]

  ## The target database for metrics; will be created as needed.
  database = "ops"

  ## If true, no CREATE DATABASE queries will be sent.  Set to true when using
  ## Telegraf with a user without permissions to create databases or when the
  ## database already exists.
  skip_database_creation = true

  ## Name of existing retention policy to write to.  Empty string writes to
  ## the default retention policy.  Only takes effect when using HTTP.
  # retention_policy = ""

  ## Write consistency (clusters only), can be: "any", "one", "quorum", "all".
  ## Only takes effect when using HTTP.
  # write_consistency = "any"

  ## Timeout for HTTP messages.
  # timeout = "5s"

  ## HTTP Basic Auth
  # dummy values
  # username = "something"
  # password = "something_else"
    username = "something"
    password = "something_else"

  ## HTTP User-Agent
  # user_agent = "telegraf"

  ## UDP payload size is the maximum packet size to send.
  # udp_payload = "512B"

  ## Optional TLS Config for use on HTTP connections.
  # tls_ca = "/etc/telegraf/ca.pem"
  # tls_cert = "/etc/telegraf/cert.pem"
  # tls_key = "/etc/telegraf/key.pem"
  ## Use TLS but skip chain & host verification
  # insecure_skip_verify = false

  ## HTTP Proxy override, if unset values the standard proxy environment
  ## variables are consulted to determine which proxy, if any, should be used.
  # http_proxy = "http://corporate.proxy:3128"

  ## Additional HTTP headers
  # http_headers = {"X-Special-Header" = "Special-Value"}

  ## HTTP Content-Encoding for write request body, can be set to "gzip" to
  ## compress body or "identity" to apply no encoding.
  # content_encoding = "identity"

  ## When true, Telegraf will output unsigned integers as unsigned values,
  ## i.e.: "42u".  You will need a version of InfluxDB supporting unsigned
  ## integer values.  Enabling this option will result in field type errors if
  ## existing data has been written.
  # influx_uint_support = false


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Read metrics about disk usage
[[inputs.disk]]

# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics.
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states.
  report_active = false


# Query Delphin data logger configured from MGO
[[inputs.delphin_datalogger]]
# Address and port of datalogger modbus port
address = "datalog"
port = 502
timeout = "20s"
slave_id = 1


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Query an antenna controller using modbus over TCP. Registers are assumed to be 32bits wide.
[[inputs.modbus_antenna]]
## modbus antenna controller type
antenna_type = "intertronics12m"
## network address in form ip:port
address = "12m:502"

# Query at MET4 meteorological measurement systems via metserver
[[inputs.met4]]
  ## Address of metserver
  address = "127.0.0.1:50001"
  ## You can add extra tags, for example
  # [inputs.met4.tags]
  #     location = "..."
  #     device = "old"


###############################################################################
#                            SERVICE INPUT PLUGINS                            #
###############################################################################


# Poll the Field System state through shared memory.
[[inputs.fieldsystem]]
## Poll the Field System state through shared memory.
##
## Record RDBE Tsys and Pcal calculated by FS.
## This complements the rdbe_multicast input.
rdbe = true
## Rate to poll FS variables.
#precision = "100ms"
version = "10.0.0-beta1"
....
